
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>


<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<base target="_top">

<style type="text/css">


/* default css */

table {
  font-size: 1em;
  line-height: inherit;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select { 
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
  }

  
    
  body { 
    min-height: 1100px; 
  }
  * html body { 
    height: 1100px; 
  }
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px; 
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  

  


  
  .br_fix br:not(:-moz-last-node):not(:-moz-first-node) {
    
    position:relative;
    
    left: -1ex
    
  }
  
  .br_fix br+br {
    position: static !important
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* end default css */


  /* default print css */
  
  @media print {
    body { 
      padding: 0; 
      margin: 0; 
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }


    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */
 

/* custom css */


/* end custom css */



  /* ui edited css */
  
  body {
    font-family: Verdana;
    
    font-size: 10.0pt;
    line-height: normal;
    background-color: #ffffff;
  }
  /* end ui edited css */



/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt; 
  line-height: 1.4; 
  padding: 1px; 
  border: 1px dashed #C0C0C0
}


/* end editor CSS */
</style>


</head>

<body onload="DoPageLoad();"
    
    revision="dhkdd78p_13kvrgbnfb:231">

    
    
    
<DIV>
  <DIV>
    <B>Geniwrapper Design Document</B>
  </DIV>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>1.0 High Level Overview</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The purpose of Geniwrapper is to provide a Geni-like interface around the
  existing planetlab infrastructure. The existing infrastructure consists of two
  parts: planetlab central (PLC) and planetlab nodes. These two parts map
  logically into the Geni Registry and Geni Components. However, it is not an
  exact mapping. Due to the nature of planetlab, some component functionality
  overlaps with PLC. For example, PLC takes an active role in managing state on
  planetlab nodes, and therefore some Geni component state exists on PLC,
  leading to some component APIs to exist on PLC.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Geniwrapper is comprised of the following logical modules: <I>utility
  classes</I>, <I>registry wrapper</I>, <I>component wrapper</I>, and <I>command
  line client</I>. Client-server communication uses a variant of XML-RPC called
  the <I>Geni protocol</I>. Section 1 of this document presents a very brief
  overview of each module. In-depth discussion occurs later.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Much of this design adheres to the SFA, and as such this document avoids
  duplication of the information already presented in the SFA. For example, the
  description of privileges, which operations are allowed by a specific
  privileges, and how privileges are assigned to principals is described fully
  in the SFA and is therefore not duplicated here.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  NOTE: <b>API documentation</b> is extracted from code comments automatically
  and is maintained in separate files, one documentation file corresponding to
  each python source file. An effort has been made to keep API documentation
  separate from this document, so that the API documentation may be
  self-maintaining as the code is updated.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Geniwrapper is checked into a subversion repository at
  <A href=http://svn.planetlab.org/geniwrapper>http://svn.planetlab.org/geniwrapper</A>.
  [TODO: verify link]
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <DIV>
    <B>1.1 Utility classes</B>
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    Utility classes include python classes that implement certificates, GIDs,
    credentials, and tickets. There are also utility classes for implementing
    the server and client stubs and the security protocol. The utility modules
    are designed to be generally re-usable. For example, the credential
    management class may be used as part of the Geni Registry, Geni Components,
    and the end-user tools that interact with Geni.
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    The&nbsp;utility classes&nbsp;are located in the
    <I>util</I>&nbsp;subdirectory.
  </DIV>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>1.2 The registry (PLC) wrapper</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The registry wrapper is intended to be colocated with PLC. All communication
  between the registry wrapper and PLC uses the PLCAPI interface and as such,
  the registry wrapper can be run on a separate machine for ease of development.
  In addition to the Geni registry operations (register, update, ...), the
  registry also implements component operations, such as GetTicket, that must be
  located on PLC due to SFA engineering decisions.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The&nbsp;registry wrapper is located in the&nbsp;<I>registry</I> subdirectory
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  TODO: Slice interface shall be implemented in registry wrapper.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>1.3&nbsp;The component wrapper</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The component wrapper is located on planetlab nodes. It implements the
  component interface, management interface, and portions of the slice
  interface. Due to SFA engineering decisions, some component operations (i.e.
  GetTicket) are implemented in the registry wrapper instead of the component
  wrapper.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The component wrapper is located in the <I>component</I> subdirectory.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>1.4 Command line client</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The command line client exports a client interface to Geni that may be used
  for testing and demonstration purposes. It allows easy invocation of Geni api
  functions and dumps the results in a human-readable format.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The command line client&nbsp;is located in the&nbsp;<I>cmdline</I>
  subdirectory
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>1.5 Geni Protocol</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The Geni protocol is based on XML-RPC. It is implemented primarily in the
  geniserver.py and geniclient.py files located with the utility classes.
  Modifications to the XML-RPC protocol include the following:
</DIV>
<DIV>
  &nbsp;
</DIV>
<OL>
  <LI>
    The transport mechanism uses HTTPS instead of HTTP.
    <LI>
      HTTPS certificate verification is disabled so that custom Geni
      verification based on GID can be done instead.
      <LI>
        When an exception occurs on the server, verbose exception information is
        sent to the client, to assist debugging efforts
      </LI>
</OL>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Authentication:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Authentication of the client by the server is done by using Credentials/GIDs.
  Generally, each operation contains a credential as the first argument. This
  credential includes the GID of the caller, which in turn contains the public
  key of the caller. The server ensures that this public key matches the public
  key that is being used to decrypt the HTTPS connection, thus ensuring the
  caller must posess the private key that corresponds to the GID.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Authentication of the server by the client is left as an exercise for the
  client. It may be done easily by specifying the server's public key when the
  client create the HTTPS connection. This presumes the client knows the public
  key (or GID) of the server he is trying to connect to.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.0 Utility Classes</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.1 Certificates and Keys (cert.py)</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Geniwrapper uses two crypto libraries: pyOpenSSL and M2Crypto to implement the
  necessary crypto functionality. Ideally just one of these libraries would be
  used, but unfortunately each of these libraries is independently lacking. The
  pyOpenSSL library is missing many necessary functions, and the M2Crypto
  library has crashed inside of some of the functions. The design decision is to
  use pyOpenSSL whenever possible as it seems more stable, and only use M2Crypto
  for those functions that are not possible in pyOpenSSL.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.1.1 Keys</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Public-private key pairs are implemented by the <B>Keypair </B>class. A
  Keypair object may represent both a public and private key pair, or it may
  represent only a public key (this usage is consistent with OpenSSL).
</DIV>
<P>
  &nbsp;&nbsp;&nbsp;&nbsp;
</P>
<DIV>
  <B>2.1.2 Certificates</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The certificate class implements a general purpose X509 certificate, making
  use of the appropriate pyOpenSSL or M2Crypto abstractions. It also adds
  several addition features, such as the ability to maintain a chain of parent
  certificates, and storage of application-specific data.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Certificates include the ability to maintain a chain of parents. Each
  certificate includes a pointer to it's parent certificate. When loaded from a
  file or a string, the parent chain will be automatically loaded. When saving a
  certificate to a file or a string, the caller can choose whether to save the
  parent certificates as well.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Example creation of a certificate:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create&nbsp;a key for an issuer<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerKey = Keypair(create=True)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerSubject = "testissuer"
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create a key for the certificate
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; userKey = KeyPair(create=True)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create the certificate, set the issuer, and
  sign it
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert = Certificate(subject="test")<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert.set_issuer(issuerKey, issuerSubject)
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert.set_pubkey(userKey)<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert.sign()
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.1.3 Certificate Verification</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <P>
    Verification examines a chain of certificates to ensure that each parent
    signs the child, and that some certificate in the chain is signed by a
    trusted certificate. Verification is a basic recursion:
  </P>
  <PRE>    if this_certificate was signed by trusted_certs:<BR>        return<BR>    else<BR>        return verify_chain(parent, trusted_certs)</PRE>
</DIV>
<DIV>
  At each recursion, the parent is tested to ensure that it did sign the child.
  If a parent did not sign a child, then an exception is thrown. If the bottom
  of the recursion is reached and the certificate does not match a trusted root,
  then an exception is thrown.
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
  <B>2.2 GIDS (gid.py)</B>
</DIV>
<DIV>
  <B></B>&nbsp;
</DIV>
<DIV>
  GIDs are a derivative class of certificates and as such the&nbsp;GID class
  inherits all the methods of the certificate class. A&nbsp;GID includes a tuple
  of the following fields:&nbsp;
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp; (uuid, hrn, public_key)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  UUID is a unique identifier and is created by the python uuid module (or the
  utility function create_uuid() in gid.py).
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  HRN is a human readable name. It is a dotted form similar to a backward domain
  name. For example, planetlab.us.arizona.bakers.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  PUBLIC_KEY is the public key of the principal identified by the UUID/HRN. It
  is a Keypair object as defined in the cert.py module.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  It is expected that there is a one-to-one pairing between UUIDs and HRN, but
  it is uncertain how this would be inforced or if it needs to be enforced.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.2.1 Encoding and Decoding</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The 5 fields of the&nbsp;GID tuple are stored in the subject-alt-name field of
  the X509 certificate. Two routines are included to package and unpackage these
  fields: Encode() and Decode(). Encode should be called prior to signing the
  GID. Decode is automatically called on demand by the various get_*()
  functions.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.2.2 Verification of GIDs</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
Verification first performs the checks of the certificate class (verifying that
each parent signs the child, etc). In addition, GIDs also confirm that the
parent's HRN is a prefix of the child's HRN. Verifying these prefixes prevents a
rogue authority from signing a GID for a principal that is not a member of that
authority. For example, planetlab.us.arizona cannot sign a GID for
planetlab.us.princeton.foo.
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.3 Credentials (credential.py)</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Credentials are a derivative class of certificates and as such the credential
  class inherits all the methods of the certificate class. A credential includes
  a tuple of the following fields:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; (GIDCaller, GIDObject, LifeTime, Privileges, Delegate)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  GIDCaller identifies the holder of the credential. When a credential is
  presented to a component, the security layer ensures that the client matches
  the public key that is contained in GIDCaller.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  GIDObject identifies the object of the credential. This object depends upon
  the type of the credential. For example, the credential for a user likely has
  GIDObject == GIDCaller. Credentials for slices would include the GID of the
  slice in the GIDObject field. Credentials for authorities include the GID of
  the authority in the GIDObject field.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  LifeTime is the lifetime of the credential. Currently not implemented; expect
  to implement it as an expiration date, and refuse credentials beyond that
  date.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Privileges is a Rights object that describes the rights that are granted to
  the holder of the credential.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Delegate is a True/False bit that indicates whether or not a credential can be
  delegated to a different caller.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.3.1 Encoding and Decoding</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The 5 fields of the credential tuple are stored in the subject-alt-name field
  of the X509 certificate. Two routines are included to package and unpackage
  these fields: Encode() and Decode(). Encode should be called prior to signing
  the credential. Decode is automatically called on demand by the various
  get_*() functions.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.3.2 Verification of Credentials</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  In addition to the checks for ordinary certificates, verification of
  credentials also ensures that the delegate bit was set by each parent in the
  chain. If a delegate bit was not set, then an exception is thrown.&nbsp;Each
  credential must also contain a subset of the rights of the parent credential
  (i.e. a user credential cannot delegate authority rights).<BR>
  <BR>
  <B>2.4 Rights (rights.py)<BR>
  <BR>
  </B>Rights are implemented by two classes:<BR>
  <BR>
  Right - represents a single right<BR>
  RightList - represents a list of rights A right may allow several different
  operations.<BR>
  <BR>
  For example, the "info" right allows "listslices", "listcomponentresources",
  etc.<BR>
  <BR>
  <B>2.5 Records (record.py)</B><BR>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The GeniRecord class implements a Geni Record. The GeniRecord class implements
  an abstract interface for the record, so that a client may use records without
  having to understant the underlying implementation details, such as whether
  the record is realized in the registry database, a local cache, or has been
  transmitted over the wire by an interface. A GeniRecord is a tuple (Name, GID,
  Type, Info).
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp; Name specifies the HRN of the object GID is the GID of the object
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp; Type is user | sa | ma | slice | component Info is comprised of the
  following sub-fields
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp; Pointer&nbsp;is a pointer to the record in the PL database
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp; pl_info&nbsp;is planetlab-specific info (when talking to client)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp; geni_info = geni-specific info (when talking to client)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The pointer is interpreted depending on the type of the record. For example,
  if the type=="user", then pointer is assumed to be a person_id that indexes
  into the persons table.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  A given HRN may have more than one record, provided that the records are of
  different types. For example, planetlab.us.arizona may have both an SA and a
  MA record, but cannot have two SA records.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.6 Tickets (geniticket.py)</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Similar to GIDs and Credentials, tickets also leverage the certificate object.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  A Ticket is tuple:<BR>
  &nbsp;&nbsp; (gidCaller, gidObject, attributes, rspec, delegate)<BR>
  <BR>
  &nbsp;&nbsp;&nbsp; gidCaller = GID of the caller performing the operation<BR>
  &nbsp;&nbsp;&nbsp; gidObject = GID of the slice<BR>
  &nbsp;&nbsp;&nbsp; attributes = slice attributes (keys, vref, instantiation,
  etc)<BR>
  &nbsp;&nbsp;&nbsp; rspec = resources
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Tickets are created by invoking GetTicket() on the Registry. The slice
  attributes and rspec are taken from the planetlab slice database and represent
  the current state of the slice. As of yet, tickets do not include any concept
  of time -- a ticket represents the state of the slice at the current time
  only.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Tickets are redeemed by invoking RedeemTicket() on the Registry. The
  attributes and spec are combined back into a planetlab slice record and handed
  off to the node manager.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Tickets are signed by an authority and include parentage information that
  traces the chain of authorities back to a trusted root.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.6.1 rspecs</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The rspec is currently a dictionary of {name: value} pairs. These pairs are
  taken verbatim from the planetlab slice database.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The general rule that is used is that things in the slice record that do not
  specifically imply a tangible resource (initscripts, keys, etc) are treated as
  attributes and things that do specify a tangible resource (disk, network, etc)
  are treated as the rspec.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  TODO: The definition of an rspec is evolving. It remains to reconcile the
  eclipse schema with Geniwrapper. Gacks is also using another rspec format,
  which may be need to be reconciled with the eclipse schema and/or geniwrapper.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <DIV>
    <B>2.6.2 Encoding and Decoding</B>
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    The 5 fields of the credential tuple are stored in the subject-alt-name
    field of the X509 certificate. Two routines are included to package and
    unpackage these fields: Encode() and Decode(). Encode should be called prior
    to signing the ticket. Decode is automatically called on demand by the
    various get_*() functions.
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    <B>2.6.3 Verification of Tickets</B>
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    Verification uses the standard parentage verification provided by the
    certificate class. Specifically, each certificate is signed by a parent, and
    some certificate must resolve to the trusted root set that is specified on
    the component.
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    Unlike credentials and GIDs, the parent of a ticket may be a degenerate
    ticket that does not include the full 5-tuple (caller, object, attributes,
    rspec, delegate). In such a case, the parent is just a placeholder in the
    chain of authority used to convey the parentage information.
  </DIV>
  <DIV>
    &nbsp;
  </DIV>
  <DIV>
    Delegation of tickets is not something that is discussed in the SFA, but it
    is supported in the ticket class and may be a useful feature. For example,
    Alice may hold a ticket for a particular component, and delegate that ticket
    to Bob. Bob could then instantiate a slice for Alice. This may be one way to
    implement a slice manager.<BR>
    <BR>
    <B>2.7 Hierarchy of Authorities (hierarchy.py)</B><BR>
    <BR>
    This module implements a hierarchy of authorities and performs a similar
    function as the "tree" module of the original geniwrapper prototype. An HRN
    is assumed to be a string of authorities separated by dots. For example,
    "planetlab.us.arizona.bakers". Each component of the HRN is a different
    authority, with the last component being a leaf in the tree. Each authority
    is stored in a subdirectory on the registry.<BR>
    <BR>
    Inside this subdirectory are several files:<BR>
    *.GID - GID file<BR>
    *.PKEY - private key file<BR>
    *.DBINFO - database info<BR>
    <BR>
    The hierarchy class can be used to create GIDs, Credentials, and Tickets for
    a given authority.
  </DIV>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The default behavior is that all authorities contained in the hierarchy will
  be located together in a single physical registry. However, this is not
  strictly necessary. The *.DBINFO files contain the database information for an
  authority and can easily be configured to point to other machines. How an
  authority would cause the DBINFO files to be installed in the correct places
  is left as a separate exercise, possibly via an out-of-band management
  interface or a web page.
</DIV>
<DIV>
  <BR>
  <B>2.8 Configuration Information (config.py)</B><BR>
  <BR>
  This module holds configuration parameters for geniwrapper. There are two main
  pieces of information that are used: the database connection and the PLCAPI
  connection.<BR>
  <BR>
  Geniwrapper uses a MYSQL database to store records. This database may be
  co-located with the PLC database, or it may be a separate database. The
  following parameters define the connection to the database. Note that
  Geniwrapper does not access any of the PLC databases directly via a mysql
  connection; All PLC databases are accessed via PLCAPI.<BR>
</DIV>
<P>
  Geniwrapper uses a PLCAPI connection to perform operations on the registry,
  such as creating and deleting slices. This connection requires an account on
  the PLC server with full administrator access. The Url parameter controls
  whether the connection uses PLCAPI directly (i.e. Geniwrapper is located on
  the same machine as PLC), or uses a XMLRPC connection to the PLC machine. If
  you wish to use the API directly, then remove the Url field from the
  dictionary.
</P>
<DIV>
  <BR>
  <B>2.8.1 Database Configuration</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Below is an example database configuration from config.py:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  def get_default_dbinfo():<BR>
  &nbsp;&nbsp;&nbsp; dbinfo={}<BR>
  &nbsp;&nbsp;&nbsp; dbinfo['dbname'] = 'planetlab4'<BR>
  &nbsp;&nbsp;&nbsp; dbinfo['address'] = 'localhost'<BR>
  &nbsp;&nbsp;&nbsp; dbinfo['port'] = 5432<BR>
  &nbsp;&nbsp;&nbsp; dbinfo['user'] = 'pgsqluser'<BR>
  &nbsp;&nbsp;&nbsp; dbinfo['password'] = '4c77b272-c892-4bdf-a833-dddeeee1a2ed'
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; return dbinfo
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  This identifies several important pieces of the database configuration. The
  name specifies the database name as used by pgsql. The address is the hostname
  (or ip-address) of the machine that is hosting the database. It is most likely
  the local machine. Port specifies the socket port where the pgsql is
  listening. The user and password authenticate Geniwrapper to the pgsql
  database. In this example, an existing PLC database was used. This is not
  strictly necessary as only Geni-specific information is stored in this
  database. A separate database could be used, on a separate machine than PLC if
  desired.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>2.8.2 PLCAPI Configuration</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Blow is an example PLCAPI configuration from config.py:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  def get_pl_auth():<BR>
  &nbsp;&nbsp;&nbsp; pl_auth = {'Username':
  <A href="mailto:'root@198.0.0.132'">'root@198.0.0.132'</A>,<BR>
  &nbsp;&nbsp;&nbsp; 'AuthMethod': 'password',<BR>
  &nbsp;&nbsp;&nbsp; 'AuthString':&nbsp; 'root',<BR>
  &nbsp;&nbsp;&nbsp; "Url":
  "<A href=https://localhost/PLCAPI/>https://localhost:443/PLCAPI/</A>"<BR>
  &nbsp;&nbsp;&nbsp; }
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; return pl_auth
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The PLCAPI configuration tells Geniwrapper how to connect to PLC. There are
  two options: a local connection or a remote connection. If the Url field is
  defined, then a remote connection is assumed, and Geniwrapper will attempt to
  connect via XMLRPC to a remote PLCAPI server. If the Url field is not defined,
  then Geniwrapper will assume that PYTHONPATH includes the relevant PLCAPI
  classes to use PLCAPI directly.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Username specifies the name of the PLCAPI user. It is suggested that a user
  with full administrative authority be allowed. Otherwise, Geniwrapper will be
  unable to lookup public keys and other information that PLC does not make
  available publicly. Administrative permission is also required to create PLC
  sites, users, etc. Authmethod and AuthString specify the password require to
  use this account.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>3.0 The Registry Wrapper</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  This wrapper implements the Geni Registry. According to the SFA, the basic
  functionality of a registry is to map HRNs into records. However, because of
  the interactions between Geniwrapper and PLC, the registry does more than act
  as a simple database. The registry performs API calls on PLC that create
  slices, sites, users, etc., and as such may indirectly cause slices to be
  instantiated on components, because components are also linked to PLC.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The mapping of Geni objects to planetlab objects is relatively
  straightforward:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; slice&nbsp;= slice
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; user&nbsp;= person
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp;&nbsp;component = node
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; sa = site
</DIV>
<DIV>
  &nbsp;&nbsp;&nbsp; ma = site
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The one part that is slightly counterintuitive is SA and MA, which both map to
  the planetlab site object. In a unified registry (a registry that serves as
  both slice and component registry), these will map to the same site record in
  the PLC database. However, there are two distinct Geni records, one&nbsp;for
  the SA and one for the MA.&nbsp;
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Registry operations generally authenticate the&nbsp;caller by credential.
  There are a few exceptions, and the registry API&nbsp;documents should note
  those exceptions.&nbsp;
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>3.1 Registry Tools</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The registry include several additional tools that are used to manage it.
  These include:
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  import.py - imports existing PLC records into the registry
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  nuke.py - deletes all Geni records
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>3.1 Bootstrapping a Registry</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  There are several items that need to be done before starting the registry.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  1) Update util/config.py to match the parameters of your PLC installation.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  2) Import the existing planetlab database, creating the appropriate geni
  records. This is done by running the "import.py" tool.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  3) Create a "trusted_roots" directory and place the certificate of the root
  authority in that directory. Given the defaults in import.py, this certificate
  would be named "planetlab.gid". For example, mkdir trusted_roots; cp
  authorities/planetlab.gid trusted_roots/
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>4.0 The Component Wrapper</B>
</DIV>
<DIV>
  <BR>
  The Geni Component Wrapper implements the Geni Component Manager. It includes
  functions for redeeming tickets, starting/stopping/resetting/deleting slices,
  and management such as rebooting the component.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The design of the component differs from the registry wrapper in the respect
  that the component wrapper must be located physically on the planetlab node
  that it is responsible for. The component wrapper interacts directly with
  portions of the node manager code on the node.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>4.1 Component Authentication of Credentials</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The component authenticates credentials the same way that the registry does.
  Specifically, there is a directory of trusted_root certificates (or GIDs) on
  the component. Any credential presented to the component must include in it's
  parentage some certificate in the set of trusted roots. Otherwise, and
  exception is thrown.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>4.2 The Ticket interface</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The ticket interface is split between the Registry (PLC) and the Component.
  This is due to the SFA engineering decisions, specifically&nbsp;that the
  authoritative copy of planetlab state is stored on PLC and only cached on the
  components. Thus, GetTicket() is implemented on the Registry, and
  RedeemTicket() is implemented on the component. InstantiateSlice is not
  implemented, as that operation is a combination of GetTicket/RedeemTicket and
  would therefore span the Registry and Component.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>4.3 Sliver Credentials</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  A recent Geni Architecture call mentioned the need for sliver credentials. A
  sliver credential would be identical to a slice credential, but would 1) only
  be redeemable on a particular component, and 2) would resolve to a
  trusted_root unique to that component (likely the component's GID
  certificate). Sliver credentials would be returned by the RedeemTicket call
  and would give the caller the permission required to start and stop the
  sliver, etc.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Sliver credentials are not yet implemented, but their implementation would be
  straightforward.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>4.4 Bootstrapping the Component Wrapper</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The first step is to install some required libraries on the component. These
  include the m2crypto and pyopenssl libraries. Installing the actual RPMs for
  these libaries on a running component proved difficult due to additional
  support packages that require installation (python-devel, etc). For
  development purposes, it was sufficient to copy the installed/compiled version
  of the libraries from the development machine to the component.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The&nbsp;second step is to copy the files required by the component wrapper to
  the node manager. They are copied to the /usr/share/Nodemanager directory. A
  list of the files is contained in the copynode.sh script in the component
  subdirectory.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The third step is to copy the trusted root certificates to the component. They
  are stored in /usr/share/Nodemanager/trusted_roots. This should include the
  certificate for the registry.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The&nbsp;fourth step is to start the component manager. This is done by
  connecting to the component via SSH and running
  /usr/share/Nodemanager/component.py.
</DIV>
<DIV>
  <BR>
  In a production environment, all of these steps would be integrated into the
  DVD boot image for the planetlab node.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.0 Command-Line Interface</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  A command-line interface is provided that allows a user to interact with the
  Geni Registry and Component. This command line interface is located in the
  cmdline directory and can be invoked by running genicli.py. Specifying
  "genicli.py help" will display a list of available commands.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.1 Examples</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Several examples of using the CLI are presented in the form of shell scripts
  in the cmdline directory. These scripts demonstrate creating slices,
  authorities, users, nodes, and getting tickets and redeeming tickets. Rather
  than duplicating all of those examples here, a few short examples are
  presented below.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.1.1 Getting a Credential</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  python ./genicli.py --username&nbsp;root --credfile None --outfile test.cred
  getCredential user planetlab.us.pl.account_test
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The credential for planetlab.us.pl.account_test is retrieved and stored in the
  local file test.cred. The private ket test.pkey is used when opening the
  XMLRPC connection and authenticates the client. test.pkey must match the
  public key that is in the GID for the user record for
  planetlab.us.pl.account_test.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Sample output: (in human-readable summary)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  CREDENTIAL planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; privs: refresh,resolve,info<BR>
  &nbsp; gidCaller:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn:
  planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid:
  276262316202422735940395896620385479122<BR>
  &nbsp; gidObject:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn:
  planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid:
  276262316202422735940395896620385479122<BR>
  &nbsp;&nbsp; delegate: False
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.1.2 Resolving a record</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  python ./genicli.py --username test resolve planetlab.us.pl.account_test
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The record for planetlab.us.pl.account_test is retrieved and printed to
  stdout. The credential used comes from the local file test.cred.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Sample output: (in human-readable summary)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  RECORD planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn: planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: user<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn:
  planetlab.us.pl.account_test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid:
  276262316202422735940395896620385479122<BR>
  &nbsp;&nbsp;&nbsp; pointer: 6<BR>
  &nbsp; geni_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; email :
  <A href=mailto:test@test.com>test@test.com</A><BR>
  &nbsp;&nbsp;&nbsp; pl_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bio : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first_name : test<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_name : account<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_updated : 1222497672<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; roles : ['user']<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_ids : [1]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enabled : True<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_ids : [24]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phone : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_person_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; role_ids : [30]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; person_id : 6<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date_created : 1219083140<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; site_ids : [1]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; email :
  <A href=mailto:test@test.com>test@test.com</A>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.1.3 Updating a record</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  python ./genicli.py --username test update user planetlab.us.pl.account_test
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  The record for planetlab.us.pl.account_test is updated. The credential used
  comes from the local file test.cred. No changes are specified, so the only
  thing that should be updated is the expiration time.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  <B>5.1.4 Resolving an authority</B>
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  An authority is an example of an HRN that might resolve to two different
  records, an SA and a MA record.
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  python ./genicli.py --username test resolve planetlab.us.pl
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  Sample Output: (in human readable summary)
</DIV>
<DIV>
  &nbsp;
</DIV>
<DIV>
  RECORD planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn: planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: sa<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn: planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid:
  294786197975089072547582920862317666209<BR>
  &nbsp;&nbsp;&nbsp; pointer: 1<BR>
  &nbsp; geni_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pi :
  ['planetlab.us.pl.Administrator_Default']<BR>
  &nbsp;&nbsp;&nbsp; pl_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_updated : 1224136003<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node_ids : [1]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; site_id : 1<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcu_ids : []<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_slices : 100<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ext_consortium_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_site_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abbreviated_name : plctest<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid :
  230749975723590978208303655640765327534<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; person_ids : [2, 4, 6]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_ids : [24, 1, 2]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latitude : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_slivers : 1000<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_public : False<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address_ids : []<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name : plctest Central<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url :
  <A href=http://198.0.0.132/>http://198.0.0.132/</A><BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enabled : True<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longitude : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; login_base : pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date_created : 1209428329<BR>
  RESULT:<BR>
  RECORD planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn: planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: ma<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrn: planetlab.us.pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid:
  294786197975089072547582920862317666209<BR>
  &nbsp;&nbsp;&nbsp; pointer: 1<BR>
  &nbsp; geni_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator : []<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner :
  ['planetlab.us.pl.Administrator_Default']<BR>
  &nbsp;&nbsp;&nbsp; pl_info:<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_updated : 1224136003<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node_ids : [1]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; site_id : 1<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pcu_ids : []<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_slices : 100<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ext_consortium_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_site_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abbreviated_name : plctest<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uuid :
  230749975723590978208303655640765327534<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; person_ids : [2, 4, 6]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_ids : [24, 1, 2]<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; latitude : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; peer_id : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_slivers : 1000<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_public : False<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address_ids : []<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name : plctest Central<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url :
  <A href=http://198.0.0.132/>http://198.0.0.132/</A><BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enabled : True<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longitude : None<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; login_base : pl<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date_created : 1209428329
</DIV>
<BR>